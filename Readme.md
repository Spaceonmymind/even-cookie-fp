## Статус чётных методов фингерпринтинга (2025)
## Тест проводился в браузерах Chrome и Safari

| №   | Метод                                                                                         | Работает в 2025 | Актуальность | Комментарий                                                                 |
|-----|-----------------------------------------------------------------------------------------------|-----|-------------|------------------------------------------------------------------------------|
| 2   | **HSTS (HTTP Strict Transport Security)**                                                    | Частично | Устаревший  | Браузеры изолируют HSTS между сайтами, кросс-доменный фингерпринт невозможен |
| 4   | **Изолированное хранилище Silverlight**                                                      | Нет | Полностью устарел | Silverlight удалён, не поддерживается                                        |
| 6   | **Сохранение cookie в истории поиска (`:visited` CSS)**                                      | Нет | Заблокирован | Современные браузеры блокируют доступ к стилям `:visited`                   |
| 8   | **Basic Auth Cache (базовая авторизация + кэш)**                                             | Да  | Частично актуален | Работает, требует тонкой настройки и контролируемого кэша                   |
| 10  | **Сторонний iframe + Fetch API + postMessage**                                               | Да  | Актуален    | Один из самых гибких и современных способов фингерпринтинга через iframe     |
| 12  | **LocalStorage HTML5**                                                                       | Да  | Актуален    | Работает в большинстве браузеров, но может очищаться вручную                |
| 14  | **WebSQL (HTML5 + SQLite)**                                                                  | Частично | Устаревший  | Работает только в Chrome, исключён из спецификации                          |
| 16  | **Java JNLP PersistenceService**                                                             | Нет | Полностью устарел | JNLP и Web Start больше не поддерживаются в Java и браузерах                |

## Метод 2: HSTS (HTTP Strict Transport Security)

### Описание метода:
HSTS — это механизм безопасности, реализуемый через HTTP-заголовок `Strict-Transport-Security`, который заставляет браузер взаимодействовать с сайтом только через HTTPS.  
Изначально создан для защиты от атак типа "man-in-the-middle", но может использоваться в целях фингерпринтинга.

Метод позволяет определить, была ли политика HSTS ранее применена к какому-либо домену. Проверка возможна путём загрузки ресурса через `http://` в `iframe` и анализа редиректа на `https://`.

### Цель:
Выявить, посещал ли пользователь определённые сайты или применялись ли к его браузеру политики HSTS, используя side-channel через `iframe`.

### Структура реализации:
- `main.html` — основная страница, создающая `iframe` с `http://`-ссылкой на проверяемый домен.
- `iframe_hsts.html` — вспомогательная страница, реагирующая на успешную загрузку (или её отсутствие).

### Как это работает:
- Если сайт с HSTS уже посещался, то `http://example.com` автоматически редиректится на `https://example.com`, и `iframe` не загрузится.
- Если HSTS не применён — `iframe` загрузится успешно и отправит сообщение "loaded".
- Это поведение позволяет определить, активна ли HSTS-политика для домена.

### Вывод:
Метод HSTS может использоваться для side-channel атак с целью определения истории посещений пользователя. Современные браузеры внедрили изоляцию контекста (например, Site Isolation), поэтому метод частично устарел, но при определённых конфигурациях может быть применим.

---

## Метод 4: Изолированное хранилище Silverlight

### Описание метода:
Изолированное хранилище (Isolated Storage) — механизм хранения данных, предоставляемый Microsoft Silverlight. Оно позволяет веб-приложениям сохранять пользовательские данные в изолированной области на стороне клиента, недоступной другим сайтам.

### Принцип работы:
- На странице размещается Silverlight-приложение (`.xap`), встроенное через `<object>` или `<embed>`.
- Приложение использует API `System.IO.IsolatedStorage` для записи уникального ID.
- Этот ID может быть передан обратно на страницу (в JavaScript) через `HtmlPage.Window.Invoke(...)`.

### Цель:
Создание устойчивого идентификатора пользователя, который не удаляется вместе с cookies или localStorage. Использовался для восстановления идентификации пользователя.

### Технические особенности:
- Работает только при установленном Silverlight-плагине.
- Поддерживается только в старых версиях Windows и Internet Explorer (до версии 11).
- Требует `.NET` и соответствующих политик безопасности.

### Реализация:
Встраивается `.xap`-модуль на страницу. В момент загрузки модуль записывает или считывает идентификатор из хранилища. Далее происходит взаимодействие с DOM через JS-мост.

### Обход и защита:
- Поддержка Silverlight прекращена во всех современных браузерах.
- Хранилище можно очистить вручную через настройки Silverlight (если оно всё ещё установлен).

### Вывод:
Метод ранее широко использовался в трекинге, особенно в банковских и мультимедийных системах, но в настоящее время считается полностью устаревшим и неприменимым.

## Метод 6: Сохранение cookie-файлов в истории поиска (History Sniffing)

### Описание метода:
History Sniffing — это метод атаки на конфиденциальность, позволявший сайтам определить, какие URL-адреса посещал пользователь, анализируя визуальные или поведенческие отличия между посещёнными и не посещёнными ссылками (используя псевдокласс `:visited` и поведение переходов).

### Принцип работы:
- Браузеры отображают посещённые ссылки иначе, чем неоткрытые.
- Ранее с помощью JavaScript можно было считывать эти различия и определять факт посещения URL.
- Использовались подгрузка ссылок, замеры стилей или времени загрузки, `iframe`-атаки.

### Цель:
Выявление истории посещений пользователя и создание уникального паттерна, позволяющего фингерпринтить по набору посещённых сайтов.

### Реализация:
- `main.html`: содержит цикл с `iframe`, в который подгружаются страницы с тестовыми ссылками.
- `iframe_history.html`: вспомогательная страница, предназначенная для определения поведения при переходе.
- Формируется массив булевых значений, где `true` — сайт был посещён, `false` — нет.

### Технические особенности:
- Уязвимость широко использовалась до 2010 года.
- Современные браузеры заблокировали доступ к стилям `:visited` через JS.
- Существуют попытки обхода с помощью timing-атак, но с низкой эффективностью.

### Защита:
- Ограничения CSS-движков.
- Изоляция истории и DOM.
- CSP-политики, запрет на доступ к iframe содержимому.

### Вывод:
Метод устарел, но остаётся значимым примером атак на приватность. В современных браузерах реализована надёжная защита от подобных side-channel техник.

---

## Метод 8: Сохранение cookie-файлов в веб-кэше (Basic Authentication Cache)

### Описание метода:
Использует механизм HTTP Basic Authentication, при котором браузер кэширует логин и пароль для определённого ресурса. Кэш может использоваться для отслеживания пользователя в пределах текущей сессии.

### Принцип работы:
- После ввода логина/пароля браузер сохраняет эти данные в памяти.
- При повторных запросах браузер автоматически аутентифицируется без запроса логина.
- Можно проверить наличие кэша, чтобы сделать вывод о предыдущей активности.

### Цель:
Определение, проходил ли пользователь авторизацию ранее, используя поведение браузера как источник side-channel информации.

### Реализация:
- Локальный сервер (`auth_server.py`) запускает защищённый HTTP-ресурс.
- `main.html` встраивает `iframe`, который обращается к этому ресурсу.
- Если `iframe` загружается без запроса логина — кэш авторизации сохранён.
- Если появляется окно ввода логина — кэш отсутствует.

### Ограничения:
- Действует только в пределах одной сессии браузера.
- Современные браузеры изолируют авторизацию между вкладками и origin.
- Кэш очищается при закрытии браузера или вкладки.
- CORS и SameSite могут блокировать такие запросы.

### Вывод:
Метод морально устарел, но интересен как пример использования механизмов безопасности для фингерпринтинга. В современных условиях практически не применяется.
## Метод 10: Использование внешнего iframe и различных API для сбора отпечатков (Different Origin + API)

### Описание метода:
Создаётся `iframe`, загружающийся с другого домена, внутри которого выполняется JavaScript-код для сбора отпечатка устройства с помощью доступных API. Данные отправляются обратно на основной сайт через `postMessage`.

### Цель:
Обойти ограничения безопасности (SameSite, ограниченный доступ к хранилищам, CSP) и получить отпечаток устройства, используя внешний домен.

### Принцип работы:
- `main-site/main.html` — основная страница.
- В неё внедряется `iframe`, загружаемый с внешнего ресурса `external_iframe/iframe.html`.
- Внутри `iframe` выполняется `external-fp.js`, который собирает данные:
  - Canvas fingerprint
  - WebGL параметры
  - UserAgent, плагины, таймзона и др.
- Результат отправляется в родительское окно через `window.parent.postMessage`.

### Преимущества:
- Устойчивость к блокировке — разделение по доменам.
- CSP-политики родителя не влияют на содержимое iframe.
- Гибкость при смене трекера — можно использовать CDN.

### Ограничения:
- Требуются два разных домена или порта (`localhost:8000`, `localhost:8001`).
- Требует корректной реализации `postMessage` с проверкой источника.
- Расширения и браузеры могут блокировать внешние `iframe`.

### Реализация:
- В каталоге `main-site/` — страница, отображающая результат.
- В `external_iframe/` — код сбора отпечатка.
- Серверы запускаются параллельно: например, `python3 server.py` на разных портах.
- Результаты видны в консоли или на экране.

### Вывод:
Современный и мощный метод трекинга, активно применяемый в антифрод-системах. Несмотря на улучшение браузерной защиты, остаётся рабочим при правильно выстроенной архитектуре.

---

## Метод 12: Использование LocalStorage (локального хранилища HTML5)

### Описание метода:
Метод использует `localStorage` — API браузера, позволяющий хранить пары ключ-значение без срока действия. Он служит альтернативой cookies, особенно при их блокировке или удалении.

### Цель:
Хранение уникального идентификатора на клиенте с возможностью доступа при последующих визитах.

### Принцип работы:
- `main.html` встраивает `iframe.html`.
- Внутри `iframe`:
  - Если `localStorage['fingerprint']` найден — он отправляется родителю.
  - Если нет — создаётся новый идентификатор, сохраняется и отправляется.
- Обмен данными осуществляется через `window.postMessage`.

### Преимущества:
- Простота и долговечность хранения.
- Не зависит от cookies.
- Отпечаток сохраняется даже после перезагрузки или закрытия вкладки.

### Ограничения:
- Доступ к `localStorage` возможен только в пределах одного origin.
- При cross-origin iframe доступ невозможен (требуется `postMessage`).
- Может очищаться вручную или автоматически (расширения, приватный режим).

### Реализация:
- `main.html` отображает результат.
- `iframe.html` содержит логику генерации/считывания отпечатка.
- Для теста запустить сервер, открыть `main.html`, обновить страницу — значение должно сохраниться.

### Вывод:
Один из самых популярных и надёжных методов клиентского хранения отпечатков. Широко используется в трекинге, аналитике, а также в механизмах cookie consent.
## Метод 14: Использование WebSQL

### Описание метода:
WebSQL — это устаревшее клиентское API, основанное на SQLite, позволяющее веб-приложениям хранить структурированные данные на стороне пользователя. Несмотря на официальное устаревание, он ещё поддерживается в некоторых браузерах, включая Safari.

### Цель:
Сохранять и считывать отпечаток устройства, используя встроенную клиентскую БД, для долговременного отслеживания пользователя.

### Принцип работы:
- В `iframe.html`:
  - Открывается база данных через `openDatabase`.
  - Создаётся таблица `fingerprint`.
  - Проверяется наличие отпечатка. Если нет — генерируется новый, сохраняется и передаётся через `postMessage`.
- В `main.html`:
  - Размещён `iframe`.
  - Обрабатывается полученное сообщение и отображается отпечаток.

### Преимущества:
- Данные хранятся вне cookies/localStorage.
- Сохраняются между сессиями.

### Недостатки:
- WebSQL официально устарел.
- Не поддерживается в большинстве современных браузеров (удалён из Chromium, Firefox).
- Поддерживается только в Safari и старых WebKit-браузерах.

### Реализация:
- `iframe.html`: взаимодействует с WebSQL.
- `main.html`: отображает результат.
- `server.py`: используется для локальной раздачи страниц, во избежание CORS-проблем.

### Вывод:
Метод был эффективен ранее, но к 2025 году его использование ограничено из-за прекращения поддержки в большинстве браузеров.

---

## Метод 16: Java JNLP PersistenceService

### Описание метода:
Использует технологию Java Web Start и API `javax.jnlp.PersistenceService` для сохранения отпечатка вне браузера — в Java-приложении, запускаемом по JNLP.

### Цель:
Надёжно сохранять отпечаток устройства вне контекста браузера, независимо от политики хранения и очистки данных.

### Принцип работы:
1. `main.html` загружает `iframe.html`.
2. В `iframe.html`:
   - Через тег `<applet>` или `<object>` загружается `persistence.jnlp`.
3. В `persistence.jnlp`:
   - Описывается `PersistenceApp.jar` с указанием `all-permissions`.
4. В `PersistenceApp.java`:
   - Используется `PersistenceService` для чтения/записи файла (`fp.txt`) в локальное Java-хранилище.
   - Отпечаток сохраняется и отправляется обратно.

### Преимущества:
- Долговременное хранилище вне браузера.
- Устойчив к удалению cookies и очистке кэша.
- Работает вне зависимости от браузерных политик.

### Недостатки:
- Требуется JRE с поддержкой Java Web Start (устарела с Java 11).
- Не поддерживается в современных браузерах.
- Требует all-permissions и доступа к файловой системе пользователя.
- Проблемы безопасности — выполнение стороннего кода на клиенте.

### Статус реализации:
- `PersistenceApp.java` не компилируется из-за отсутствия `javax.jnlp.*` в современных JDK.
- Вызов JNLP корректно вставлен в `iframe.html`.
- `server.py` отдаёт необходимые файлы, но запуск невозможен без специфической Java-среды (например, Oracle Java 8 с Web Start).

### Вывод:
Метод обладает высокой устойчивостью и независимостью от браузера, но является устаревшим и на практике не работает в текущих условиях без ручной настройки окружения пользователя.

